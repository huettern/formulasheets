

% Advanced Topics in Communication Networks D-ITET
% ===========================================================================
% @Author: Noah Huetter
% @Date:   2019-09-24 17:26:28
% @Last Modified by:   noah
% @Last Modified time: 2020-02-04 14:19:39
% ---------------------------------------------------------------------------

\documentclass[a4paper, fontsize=8pt, landscape, DIV=1]{scrartcl}
\usepackage{lastpage}
\usepackage{hyperref}
% Include general settings and customized commands
\input{settings/general}
\input{settings/commands}

% This package makes formulas a bit more compact but less beautiful
% \usepackage{newtxtext,newtxmath}

% scala language description
\lstdefinelanguage{BNF}{%
    alsoletter={-},%
    sensitive,%
}[keywords,comments]%


% scala language description
\lstdefinelanguage{P4}{%
    sensitive,%
    backgroundcolor=\color{codeblue},%
%    morecomment=[l]//,%
%    morecomment=[s]{/*}{*/},%
}[keywords,comments]%

\definecolor{codeblue}{HTML}{DEF0FE}
\lstdefinestyle{P4style}{
    language=P4,%
    frame=none,%
    backgroundcolor=\color{codeblue},%
    keywords={action, action_function_declaration, action_profile, action_selector, algorithm, and, apply, attribute, attributes, bit, bytes, bytes_and_packets, calculated_field, control, counter, direct, dynamic_action_selection, else, extern, extern_type, extract, false, field_list, field_list_calculation, fields, header, header_type, hit, if, in, inout, input, instance_count, int, last, layout, mask, max, metadata, meter, method, min, min_width, miss, next, not, optional, or, output_width, packets, parse_error, parser, parser_drop, parser_exception, parser_value_set, primitive_action_declaration, range, register, result, return, saturating, select, selection_key, set_metadata, signed, static, table, true, update, valid, varbit, verify, width},%
    basicstyle=\ttfamily,%
    aboveskip=3mm,%
    belowskip=3mm,%
    fontadjust=true,%
    keepspaces=true,%
    keywordstyle=\bfseries,%
    captionpos=b,%
    framerule=0.3pt,%
    firstnumber=0,%
    numbersep=1.5mm,%
    numberstyle=\tiny,%
}
\lstset{%
    basicstyle=\ttfamily,%
%    language=P4,%
    aboveskip=3mm,%
    belowskip=3mm,%
    fontadjust=true,%
%    columns=[c]fixed,%
    keepspaces=true,%
%    commentstyle=\itshape,%
    frame=single,
    keywordstyle=\bfseries,%
    captionpos=b,%
    framerule=0.3pt,%
    firstnumber=0,%
    numbersep=1.5mm,%
    numberstyle=\tiny,%
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

% \bibliography{semiconductordevices}
% \bibliographystyle{ieeetr}
\medmuskip=1mu

%change page style for header
\pagestyle{fancy}
\footskip 20pt

% Uncomment this line to make formulasheet ultra compact
% This removes
% - list of variables
% \newcommand{\makeultracompact}{irrelevant}
\let\makeultracompact\undefined

% Make stuff ultra compact if so desired
\ifdefined\makeultracompact
  \setlength{\parskip}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
\else
\fi
 
% -----------------------------------------------------------------------
\IfFileExists{../build/revision.tex}{
  \input{../build/revision.tex}
  \rhead{Compiled: \compiledate \hspace{1em} on: \hostname \hspace{1em} git-sha: \revision \hspace{1em} Noah Huetter}
}{\rhead{Noah Huetter}}

\ifdefined\makeultracompact
  \lhead{ETH Advanced Topics in Communication Networks 2019 \hspace{1em}compact version}
\else
  \lhead{ETH Advanced Topics in Communication Networks 2019}
\fi
\chead{\thepage}
\cfoot{}
\headheight 17pt \headsep 10pt
\title{ETH Advanced Topics in Communication Networks 2019}
\author{Noah Huetter}

\date{\today}
\begin{document}

\setcounter{page}{0}
\setcounter{secnumdepth}{2} %no enumeration of sections
\begin{multicols*}{4}
	\section*{Disclaimer}
	This summary is part of the lecture ``ETH Advanced Topics in Communication Networks'' (227-0575-00L) by Prof. Dr. Laurent Vanbever (FS19). It is based on the lecture slides 
  that can be found at \href{https://adv-net.ethz.ch/}{adv-net.ethz.ch}. \\[6pt]
	Please report errors to \href{mailto:huettern@student.ethz.ch}{huettern@student.ethz.ch} such that others can benefit as well.\\[6pt]	
  The upstream repository can be found at \href{https://github.com/noah95/formulasheets}{https://github.com/noah95/formulasheets}
	\vfill\null
  \columnbreak
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \setcounter{tocdepth}{2}
  \tableofcontents
  \vfill\null
  %\columnbreak
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\pagebreak
  \maketitle 
  \setcounter{page}{1}
  \thispagestyle{fancy}


  % ---------------------------------------------------------------------------
  \section{Motivation}
  % ---------------------------------------------------------------------------
  Complexity + Low-level Management = Problems. Human factors are responsible
  for 50\% to 80\% of network outages. Solving problems used to be hard because
  network devices tend to be completely locked down.

  % ---------------------------------------------------------------------------
  \section{Software-Defined Networking}
  % ---------------------------------------------------------------------------
  A new approach to networking: Not about architecture (IP, TCP, etc.) but 
  about design of network control (routing, TE, ...). \textbf{Separates the
  control-plane from the data-plane}. It doesn't do much but enables a lot.

  \cgraphic{0.8}{img/sdntopo.png}

  \subsection{Advantages}
  \begin{itemize}
    \item Simpler management
    \item Faster pace of innovation
    \item Easier interoperability
    \item Simpler, cheaper equipment
  \end{itemize}

  % ---------------------------------------------------------------------------
  \section{OpenFlow}
  % ---------------------------------------------------------------------------
  OpenFlow is an API to a switch flow table. Match, action, priority.
  \cgraphic{0.8}{img/openflow.png}

  Enables different kinds of boxes:
  \begin{itemize}
    \item Router: Match LPM, Action: forward out a link
    \item Switch: Match destination MAC, Action: forward of flood
    \item Firewall: Match: IP, port, Action: permit or deny
  \end{itemize}

  \subsection{Example Applications}
  \begin{itemize}
    \item Dynamic access control
    \item Seamless mobility/migration
    \item Server load balancing
    \item ...
  \end{itemize}

  \subsection{Challenges}
  \begin{outline}
    \1 Heterogeneous Switches
      \2 Number of packet-handling rules
      \2 Range of matches and actions
    \1 Controller Delay and Overhead
      \2 Controller is much slower than the switch
      \2 Provessing packets leads to delay and overhead
      \2 Need to keep most packets n the "fast path"
    \1 Testing and Debugging
      \2 OpenFlow makes programming possible
      \2 Plenty of room for bugs
    \1 Programming Abstractions
      \2 OpenFlow is a loq-level API
      \2 Makes netowrk programming possible, not easy!
  \end{outline}

  \subsection{Disadvantages}
  \begin{outline}
    \1 Protocol is too complex:
    Switches must support complicated parsers and pipelines
    \1 The specificatino itself keeps getting more complex
    \1 Switches vendor end up implementing parts of the spec
  \end{outline}

  % ---------------------------------------------------------------------------
  \section{Protocol Independent Switch Architecture}
  % ---------------------------------------------------------------------------
  PISA: Protocol Independent Switch Architecture for high-speed programmable
  packet forwarding. By default PISA doesn't do anything, it's just an "architecture".
  \cgraphic{1}{img/pisa.png}

  PISA + P4 is strictly more general OpenFlow
  \cgraphic{1}{img/pisap4.png}

  % ---------------------------------------------------------------------------
  \section{P4}
  % ---------------------------------------------------------------------------
  \subsection{Structure}
  A P4 program consists of three basic parts: Parser, Match-Action Pipeline and
  Deparser. 

  \textbf{Parser} Programmer declares the headers that should be recognized and
  their order in the packet. 
  \textbf{Match-Action Pipeline} Programmer defines the tables and the processing
  logic.
  \textbf{Deparser} Programmer declares how the output packet will look on the wire.

  \subsection{Basic Building Blocks}
  The control consists of control flow, actions and tables.
  \textbf{control flow} describes how packets should be processed.
  \textbf{actions} fragments manipulating headers fields/metadata.
  \textbf{tables} map user-defined keys with actions.

  \cgraphic{1}{img/matchaction.png}

  \subsection{Environment}
  P4-16 introduces the concept of an architecture. The P4 Target is a model 
  of a specific hardware implementation and the P4 Architecture an API to
  program a target.

  \cgraphic{1}{img/p4env.png}  

  In this course, we'll rely on a simple P4-16 switch architecture \texttt{v1model}.
  Each architecture defines the \textbf{metadata} it supoprts, including both standard and 
  intrinsic ones. It also defines a list of "externs", ie. blackbox functions whose interface
  is known. Examples are:
  \begin{outline}
   \1 Registers
   \1 Random number generators
   \1 Hash functions
  \end{outline}

  \subsection{Language}
  P4-16 is a statically-typed language with base types and operators to derive composed ones.
  There exist no floating point variables, no division and modulo. Variables have local scope and
  their values is not maintained across subsequent invocations. They cannot be used to
  maintain state between different network packets. Instead you use tables or external
  objects.

  Loops are only possible during the parser stage. Parser contains advanced concepts such as
  verify (error handling), lokahead (access bits that are not parsed yet) and sub-parsers
  (like subroutines).

  \subsubsection{Tables}
  Can match on one or multiple keys in different ways. \texttt{exact}
  comparison, \texttt{ternary}: compare with mask, \texttt{lpm} longest prefix match.
  Architectures can add matches such as \texttt{range} in v1model.

  Tabe entries are added through the control plane.
  \cgraphic{1}{img/p4table.png}  
  
  \subsubsection{Actions}
  Are blocks of statements that possibly modify the packets. Usually take directional
  parameters indicating how the corresponding value is treated within the block.
  \texttt{in}: read only inside the action, \texttt{out}: Uninitialized, write inside action,
  \texttt{inout}: Combination. Actions parameters resulting from a table lookup do not 
  take a direction as they come from the control plane.

  \subsubsection{Control flow}
  Apllying a table \texttt{.apply()}, checking if there was a hit \texttt{.hit} and check which action was executed \texttt{.apply().action\_run}. Validating and computing checksums
  using externals. And more advanced concepts:
  \begin{outline}
   \1 Cloning packets
   \1 Sending packets to control plane
   \1 Recirculting (send packet through pipeline multiple times)
  \end{outline}

  \subsection{Keeping State}
  Registers can be used to store arbitrary data to keep track of state accross
  packet boundaries.

  Example of stateful firewall:
  \cgraphic{1}{img/statefulfirewall.png}

  \texttt{counter} can also be used, they cannot be read from the dataplane however.
  Counters can be attached to tables to count table entry hit count.

  \texttt{meter} can be used for rate-limiting. 

  \texttt{direct\_meter} can be associated with a table to count entries matched.

  \cgraphic{1}{img/statesummary.png}


  % ---------------------------------------------------------------------------
  \section{Probabilistic Data Structures}
  % ---------------------------------------------------------------------------
  We are provided with built-in stateful data structures such as arrays of registers, 
  counters or meters. We need to deal with severe limitations such as a limited
  number of operations and memory. \textbf{Today}: How can we implement a set with
  its usual methods? I.e., add an element, membership query, delete an element,
  lookup, listing.

  \begin{center}
  \begin{tabular}{l | c | c }
    {} & strategy 1 & strategy 2 \\ \hline
    output & Deterministic & Probabilistic \\
    number of ops & Probabilistic & Deterministic
  \end{tabular}
  \end{center}

  \subsection{Separate-chaining}
  Intuitive impleentation of a set. An input is hashed to yield a index from 0 to
  register size - 1. \textbf{Pro}: Accurate and fast in average case. \textbf{Con}:
  only works in hardware if there is a low number of elements (e.g. < 100).

  $N$ elements and $M$ cells.
  \begin{center}
  \begin{tabular}{l  c }
    {} & list size \\
    average & $N/M$ \\
    worst-case & $N$
  \end{tabular}
  \end{center}

  \subsubsection{Insertions}
  Hash the input value and set the bit at the hash location to $1$/$0$.
  \subsubsection{Membership query}
  Hash the input value and check the bit at the hash location. There could be
  false positives, if two input words result in the same hash value.

  $N$ elements and $M$ cells.
  \begin{center}
  \begin{tabularx}{\columnwidth}{X c}
  Prob. of element to be maped into particular cell & $\frac{1}{M}$ \\
  Prob. of element not to be mapped into particular cell & $1-\frac{1}{M}$ \\
  \textbf{False positive rate (FPR)} & $1 - (1-\frac{1}{M})^N$ \\
  False negative rate & $0$
  \end{tabularx}
  \end{center}

  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} = 1 - \left(1-\frac{1}{M}\right)^N
    \end{gathered}
  \end{empheq}

  E.g. for 1'000 elements into 10'000, FPR = 9.5\%.

  \textbf{Pro}: Simple and only one operation per insertion or query \textbf{Con}:
  Roughly 100x more cells are required than the number of elements we want to
  store for a 1\% FPR.

  \subsection{Bloom Filters}
  A more memory-efficient approach for insertions and membership queries. Use $K$ 
  hash functions to map $N$ elements into $M$ cells. For insertion set all cells
  of the $K$ hash values. An element is considered in the set if \textbf{all} the hash
  values map to a cell with $1$. An element is not in the set if \textbf{at least} one
  hash value maps to a cell with $0$.

  $N$ elements, $M$ cells and $K$ hash functions.
  \begin{center}
  \begin{tabularx}{\columnwidth}{X c}
  Prob. that one hash fun. returns idx of particular cell & $\frac{1}{M}$ \\
  Prob. that one hash fun. does not return idx of particular cell & $1-\frac{1}{M}$ \\
  Prob. of cell to be $0$ & $(1-\frac{1}{M})^{KN}$ \\
  \textbf{False positive rate (FPR)} & $(1 - (1-\frac{1}{M})^{KN})^K$ \\
  False negative rate & $0$
  \end{tabularx}
  \end{center}

  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} = \left(1 - \left(1-\frac{1}{M}\right)^{KN}\right)^K
    \end{gathered}
  \end{empheq}

  E.g. 1'000 elements, 10'000 cells, 7 hash functions 0.82\% FPR.

  \textbf{Pro}: Consumes roughly 10x less memory than the simple approach \textbf{Con}:
  Requires slightly more operations than the simple approach

  \subsubsection{Dimensioning}
  Is a tradeoff between memory, number of operations and false positive rate.

  $N$ elements\\
  $M$ cells\\
  $K$ hash functions \\
  $\text{FP}$ false positive rate
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} \approx \left(1 - e^{-KN/M}\right)^K
    \end{gathered}
  \end{empheq}

  There is always a global minimum when $N$, $M$ are given.
  \cgraphic{1}{img/bloomplot.png}

  \subsubsection{Implementation}
  Depending on hardware limitations, splitting the bloom filter might be required.
  $M$ cells are split into $M/K$ disjoint groups. An element is hashed to $K$ cells, 
  one in each group. One hash function per group. Same performance, may be easier
  to implement or parallelize.

  \subsubsection{Reset}
  Because deletions are not possible, the controller may need to regularly reset the
  bloom filters. Resetting a bloom filter takes some time during which it is not
  usable. Common trick: Use two bloom filters and use one when the controller resets
  the other one.

  \subsection{Counting Bloom Filters}
  Problem with Bloom Filters is that they cannot handle deletions. Counting Bloom
  Filters \textbf{increment} the corresponding counters on insertion and \textbf{decrement}
  upon deletion. All of the prior analysis applies to counting bloom filters.

  Counting Bloom Filters do handle deletions at the price of using more memory. Counters
  must be large enough to avoid overflow or else there are false negatives. Poisson
  approcimation suggests \textbf{4 bits/counter}.

  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \text{FPR} = \left(1 - \left(1-\frac{1}{M}\right)^{KN}\right)^K
    \end{gathered}
  \end{empheq}

  \subsection{Invertible Bloom Lookup Tables (IBLT)}
  IBLT store key-value pairs and allow for lookups and a complete listing. Each cell
  contains three fields: \\
  \textbf{count} which counts the number of entries mapped to this cell\\
  \textbf{keySum} is the sum of all keys mapped to this cell\\
  \textbf{valueSum} is the sum of all values mapped to this cell

  \subsubsection{Add}
  Assuming it is not in the set.
  \begin{outline}
   \1 For each hash function, hash the key to find the index. Then at this index
    \2 Increment the count by one
    \2 Add key to keySum
    \2 Add value to valueSum
  \end{outline}
  \cgraphic{0.6}{img/ibltinsert.png}

  \subsubsection{Delete}
  Assuming it is in the set.
  \begin{outline}
   \1 For each hash function, hash the key to find the index. Then at this index
    \2 Decrement the count by one
    \2 Subtract key to keySum
    \2 Subtract value to valueSum
  \end{outline}

  \subsubsection{Lookup}
  The value of a key can be found if the key is associated to at least one 
  cell with a count = 1.
  \cgraphic{0.6}{img/ibltlookup.png}

  \subsubsection{Listing}
  \begin{outline}
   \1 While there is an index for which count = 1
    \2 Find the corresponding key-value pair and return it
    \2 Delete the coresponding key-value pair
  \end{outline}
  Unless the number of iterations is very low, loops can not be implemeted 
  in hardware. The listing is done by the controller.

  \subsubsection{Tricks}
  In many settings, we can use XORs in place of sums for example to avoid
  overflow issues.

  \subsection{Sketches in General}
  Problem: Data stream with $n$ elements in totel, in the worst case $n$
  distinct elements and we want to count \textit{frequencies}, or how many
  times an element occurs. $n$ counter required would be memory inefficient.

  Sketches provide approximate frequencies of elements in a data stream. More 
  efficient by allowing mis-counting. Notation:
  \begin{empheq}{gather*}
    \vect{x} = \begin{bmatrix}x_1\\x_2\\\vdots\end{bmatrix}
  \end{empheq}
  Vector of frequencies (counts) of all distinct elements $x_i$.

  \subsection{CountMin sketch}
  Uses the same principles as a counting bloom filter, but is designed to have
  provable L1 error bounds for frequency queries.

  The estimation error exceeds $\norm{x}_1$ with a probability smaller than $\delta$:
  \begin{empheq}{gather*}
    \P(\hat{x}_i - x_i \geq \epsilon \norm{x}_1) \leq \delta
  \end{empheq}
  $\hat{x}_i$ Estimated frequency\\
  $x_i$ True frequency\\
  $\epsilon \norm{x}_1$ sum of frequencies.

  Let $\norm{x}_1=10000$, $\epsilon=0.01$, $\delta=0.05$: The probability for
  any estimat to be off by more than 100 is less than 5\% after counting 10000 elements.

  \subsubsection{Principle of Operation}
  $w\times d$ counters where $w$ inices per array is the range of hashes and $d$
  number of arrays with one hash function per array.
  \cgraphic{0.6}{img/cms.png}

  Count: Hash stream and increment the corresponding counter in each array.

  Query: Return the minimum value of the counters.

  \subsubsection{Error bounds}
  The proof is omitted and can be found in the lecture slides.
  
  Error bounds per hash/array:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \P(\hat{x}_i^{(h)} - x_i \geq \epsilon^{(h)}\norm{x}_1) \leq \delta^{(h)} \\
      \P(\hat{x}_i^{(h)} - x_i \geq \frac{c}{w}\norm{x}_1) \leq \frac{1}{c}
    \end{gathered}
  \end{empheq}
  $c$ from Markov inequality\\
  $w$ hash range\\
  $\hat{x}_i^{(h)}$ estimate for specific hash

  Error bounds for the minimum:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \P(\hat{x}_i - x_i \geq \frac{c}{w}\norm{x}_1) \leq \frac{1}{c^d}
    \end{gathered}
  \end{empheq}

  Optimal size:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      \epsilon = \frac{c}{w} \leadsto w = \left\lceil\frac{c}{\epsilon}\right\rceil \\
      \delta = \frac{1}{c^d} \leadsto d = \left\lceil\log_c\frac{1}{\delta}\right\rceil
    \end{gathered}
  \end{empheq}
  $w$ hash range\\
  $d$ number of hashes

  Choosing $c=e$ minimizes the total number of counters.

  \subsubsection{Recipe}
  Choose:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      d = \left\lceil\ln\frac{1}{\delta}\right\rceil \quad w=\left\lceil\frac{e}{\epsilon}\right\rceil
    \end{gathered}
  \end{empheq}

  Then $\hat{x}_i-x_i\geq\epsilon\norm{x}_1$ with a probability less than $\delta$.

  \subsubsection{Summary}
  A CountMin sketch uses the same principles as a counting bloom filter, but is
  designed to have provable L1 error bounds for frequency queries. It is only one
  design out of many.

  \subsection{Count sketch}
  Uses the same principles as a counting bloom filter, but is designed to have 
  \textbf{provable L2 error bounds} for frequency queries.

  Extends CountMin sketch by $g: U\to\{+1,-1\}$. For count instead of increment,
  add $g(x_i)$ to the cell. For query instead of minimum, return median of $\text{reg}[h(x_i)]g(x_i)$

  \subsubsection{Recipe}
  Choose:
  \begin{empheq}[box=\eqbox]{equation*}
    \begin{gathered}
      d = \left\lceil\ln\frac{1}{\delta}\right\rceil \quad w=\left\lceil\frac{e}{\epsilon^2}\right\rceil
    \end{gathered}
  \end{empheq}

  Then $\hat{x}_i-x_i\geq\epsilon\norm{x}_2$ with a probability less than $\delta$.

  \subsection{Summary}
  Sketches compute statistiacl summaries, favoring elements with high frequency.
  Error relative to flow size is larger for smaller flows.

  Regardless of their limitations, sketches provide trade-offs between resources and error, and 
  provable gurarantees to rely on.

  % ---------------------------------------------------------------------------
  \section{P4 Hardware Target}
  % ---------------------------------------------------------------------------
  How do we build a fast repgrogrammable switch?

  \subsection{Reconfigurable Match Tables (RMT)}
  Problem> A fixed function switch is compoesd of a (de-)parser and a sequence of
  processing stages. In such a switch, each stage is particularized to its usage. 
  This specificity makes it impossible to 
  \begin{outline}
   \1 Trade memory size for another
   \1 Add new tables
   \1 Support new headers or new actions
  \end{outline}
  \cgraphic{0.9}{img/ffs.png}

  SDN requires
  \begin{outline}
   \1 Multiple stages of match-action
   \1 Flexible actions
   \1 Flexible header fields
  \end{outline}

  So we need a flexible switch chip. The challendes:
  \begin{outline}
   \1 Big chip
   \1 High frequency
   \1 Wiring intensive
   \1 Many crossbars
   \1 Lots of TCAM (ternary content addressable memory)
  \end{outline}

  \begin{tabularx}{\columnwidth}{X l}
    Throughput & 1 Tbps \\
    Avg. Packet size & 1000 bits \\
    Avg. \# Operations & 10\\
    \textbf{Requirements} & \textbf{10 billion op/sec}
  \end{tabularx}

  Solution: Pipelining
  \cgraphic{0.9}{img/pipe.png}

  \subsubsection{Parser}
  The parse graph contains nodes which correspond to a header field and identifies the 
  next field that follows. We need:
  \begin{outline}
   \1 a programmable parser that runs at line-rate (1 packet every 70ns on a 10Gbps link)
   \1 Involves sequential processing
   \1 Some require lookahead
   \1 Many header formats exist that can appear in various orders/locations
  \end{outline}

  A parser can be divided into two seperate blocks: header identification (implements
  the parse graphs state machind) and field extraction (extracts the chosen fields from
  identified headers). In programmable parser, the two modules rely on runtime information instead
  of hard-coded logic (stored in RAM and/or TCAM). TCAM stores the bit sequences that identify
  the headers, action RAM stores the next state, fields to extract, etc. 
  \cgraphic{1}{img/parser.png}

  \subsubsection{Logical Pipeline}
  A compiler translates a given RMT logical pipeline (specified in P4) into a 
  physical one. Each physical stage contains dedicated SRAM for exact matches and
  TCAM for ternary matches. Small tables can share a stage while large tables can
  span multiple ones.
  \cgraphic{0.9}{img/memspan.png}

  Each ALU modifies only one word of a header. E.G. a header is composed of 224 words
  and the pipeline has 24 stages. Each stage contains one ALU per word of the header vector
  an can execute VLIW instructions (very long instrucion words).
  \begin{outline}
  \1 64x10Gb ports
    \2 960M packets/second
    \2 1GHz pipeline
  \1 Programmable parser
  \1 32 Match/action stages
  \1 Huge TCAM: 64K TACM words x 640b
  \1 SRAM hash tables for exact matches: 128K words x 640b
  \1 224 action processors per stage
  \end{outline}
  \cgraphic{0.9}{img/alu.png}

  Building a RMT pipelinei s only 15\% more expensive than building a fixed-function 
  switching pipeline. The biggest cost is the memory, not the processing logic. Die usage:
  \begin{outline}
  \1 30\% SerDes (serializer/deserializer)
  \1 20\% Processing logic
  \1 50\% Memory
  \end{outline}

  \subsection{Example: Barefoot Tofino}
  A 6.5 Tbps backplane that processes several billion packets per second at line rate.
  4 Match/Action pipelines that are fully programmable PISA embodiment. Relies on
  Packet Header Vector (PHV) to pass states between stages. Folded pipeline: Same 
  stages are used for both ingress an egress pipeline. Follows the RMT pipeline.

  \subsubsection{Parallel Processing}
  \begin{outline}
  \1 Multiple tables mean multiple parallel lookups
  \1 All actinos from all active tables are combined
  \1 Each PHV container has its own, independent processor
  \end{outline}

  % ---------------------------------------------------------------------------
  \section{P4-Based Applications}
  % ---------------------------------------------------------------------------
  \begin{outline}
  \1 Data plane programmability for
    \2 Performance
    \2 Monitoring
    \2 Applications offloading
  \1 for Data plane programmability
    \2 Platforms
    \2 Correctness
    \2 Management
  \end{outline}

  \subsection{Data plane programmability for..}

  \subsubsection{..performance}
  Example of \textbf{load balancing}, CONGA: Leaf switches (top-of-rack) track congestion to other leaves on different
  paths in real-time. Use greedy decisions to minimize bottleneck uitl. Fast feedback
  loops between leaf switches, directly in dataplane.

  \subsubsection{..monitoring}
  In-band Network Telemetry: Mechanism for collecting network state in the dataplane.
  As close to realtime as possible at current and future line rates. Header that carries
  path utilization. Scales to arbitrarily large networks.

  \subsubsection{..Applications offloading}
  NetCache: Balancing Key-Value Stores with Fast In-Network Caching. Solves the problem of
  load-balancing in key-values stores observing dynamic, skewed workload. Small but
  very fast cache can provide perfect load-balancing (in theory).
  \cgraphic{0.9}{img/netcache.png}

  \subsection{.. for data plane programmability}

  \subsubsection{Platforms..}
  Combining host-based programmability, SmartNICs (FPGA) and programmable switches
  to get a fully programmable platform.

  \subsubsection{Correctness..}
  p4v: Practical Verification for Programmable Data Planes. Checks for header validity, 
  unambiguous forwarding, mutual exclusion of headers, etc.

  \subsubsection{Management..}
  How to perform planned maintenance, run multiple applications in the switch and
  share resources amongs applications. Need an operating system for data plane. 

  % ---------------------------------------------------------------------------
  \vfill\null
  \pagebreak
  \end{multicols*}
  \begin{multicols*}{3}
  \section{P4 language}
  % ---------------------------------------------------------------------------
  \subsection{Data types}

  \subsubsection{Base types}

  \begin{tabularx}{\linewidth}{ l X}
    \lstinline[style=P4style]!bool! &
    Boolean value\\
    \lstinline[style=P4style]!bit<W>! &
    Bit-string of width \texttt{W}\\
    \lstinline[style=P4style]!int<W>! &
    Signed integer of width \texttt{W}\\
    \lstinline[style=P4style]!varbit<W>! &
    Bit-string of dynamiv length \texttt{<=W}\\
    \lstinline[style=P4style]!match_kind! &
    describes ways to match table keys\\
    \lstinline[style=P4style]!error! &
    used to signal errors\\
    \lstinline[style=P4style]!void! &
    no values, used in few restricted circumstances\\
  \end{tabularx}

  \subsubsection{Header}
  Parsing a packet using \texttt{extract()} fills in the fields of the header.
  A successful \texttt{extract()} sets to true the validity bit of the extraced header.

  \begin{lstlisting}[style=P4style]
action:
header Ethernet_h {
  bit<48> dstAddr;
  bit<48> srcAddr;
  bit<16> etherType;
}
Ethernet_h ethernetHeader;
\end{lstlisting}

  \subsubsection{Header Stack}
  Array of up to \texttt{N} headers of type \texttt{Mpls\_h}.

\begin{lstlisting}[style=P4style]
header Mpls_h {
  bit<20> label;
  bit<3>  tc;
  bit     bos;
  bit<8>  ttl;
}
Mpls_h[10] mpls;
\end{lstlisting}

  \subsubsection{Header union}
Either \texttt{IPv4} or \texttt{IPv6} header is present.

\begin{lstlisting}[style=P4style]
header_union IP_h {
 IPv4_h v4;
 IPv6_h v6;
}
\end{lstlisting}


  \subsubsection{Struct}
  Unordered collection of named members.

\begin{lstlisting}[style=P4style]
struct standard_metadata_t {
 bit<9> ingress_port;
 bit<9> egress_spec;
 bit<9> egress_port;
 ...
}
\end{lstlisting}

  \subsubsection{Tuple}
  Unordered collection of unnamed members.

\begin{lstlisting}[style=P4style]
tuple<bit<32>, bool> x;
x = { 10, false }
\end{lstlisting}

  \subsubsection{Other}
  \begin{tabularx}{\linewidth}{ l X}
  \lstinline[style=P4style]!enum Prio \{High, Low\}! &
  Enumeration \\
  \lstinline[style=P4style]!typedef bit<48> macAddr_t! &
  Create subtypes \\
  \lstinline[style=P4style]!extern! &
  {}  \\
  \lstinline[style=P4style]!parser! &
  {}  \\
  \lstinline[style=P4style]!control! &
  {}  \\
  \lstinline[style=P4style]!package! &
  {}  \\
  \end{tabularx}

  \subsection{Data structures}

  \begin{lstlisting}[style=P4style]
struct standard_metadata_t {
  bit<9>  ingress_port;
  bit<9>  egress_spec;
  bit<9>  egress_port;
  bit<32> instance_type;
  bit<32> packet_length;
  bit<32> enq_timestamp;
  bit<19> enq_qdepth;
  bit<32> deq_timedelta;
  bit<19> deq_qdepth;

  // intrinsic to metadata v1model
  bit<48> ingress_global_timestamp;
  bit<48> egress_global_timestamp;
  bit<16> mcast_grp;
  bit<16> egress_rid;
  bit<1>  checksum_error;
  error parser_error;
  bit<3> priority;
}\end{lstlisting}

\begin{tabularx}{\linewidth}{ l X }
  \lstinline[style=P4style]!ingress_port! &
  Port the packet was received \\
  \lstinline[style=P4style]!egress_spec! &
  Port where the packet will be transmitted \\
\end{tabularx}

\subsection{Operations}
  \begin{tabularx}{\linewidth}{ l X}
  \lstinline[style=P4style]!+ - *! &
  Arithmetics \\
  \lstinline[style=P4style]!\~ \& \| \^ >> <<! &
  logical operations (NOT, AND, OR, XOR, SHL, SHR) \\
  \lstinline[style=P4style]![m:l]! &
  Bit slicing  \\
  \lstinline[style=P4style]!++! &
  Bit concatenation 
  \end{tabularx}

\subsection{Externs}
  \subsubsection{Register}
  Store state.
  \begin{lstlisting}[style=P4style]
// create
register<bit<WIDTH>>(REGISTER_SIZE) my_reg;
// read
my_reg.read(meta.value, location);
// write
my_reg.write(location, meta.value);\end{lstlisting}

  \subsubsection{Hash}
  For the five tuple in the hash function use concatenation using curly braces like this:
  \begin{lstlisting}[style=P4style]
hash(
  meta.ecmp_hash, // out
  HashAlgorithm.crc16, // algo
  14w0, // base
  { hdr.ipv4.srcAddr,hdr.ipv4.dstAddr,hdr.ipv4.protocol,hdr.tcp.srcPort,hdr.tcp.dstPort },
  num_nhops // max
);\end{lstlisting}


\subsection{P4 Program Structure}
  \subsubsection{Parser}
  A typical parser up to TCP without UDP looks like this:
  \begin{lstlisting}[style=P4style]
parser MyParser(packet_in packet,
    out headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata) {

  state start {
    transition parse_ethernet;
  }

  state parse_ethernet {
    packet.extract(hdr.ethernet);
    transition select(hdr.ethernet.etherType) {
      0x800: parse_ipv4;
      default: accept;
    }
  }

  state parse_ipv4 {
    packet.extract(hdr.ipv4);
    transition select(hdr.ipv4.protocol) {
      0x06: parse_tcp;
      default: accept;
    } 
  }

  state parse_tcp {
      packet.extract(hdr.tcp);
      transition accept;
  }
}\end{lstlisting}

  \subsubsection{Ingres}
  Here you define actions and tables and apply them accordingly.

  \subsubsection{Tables}
  Match types

  \begin{tabularx}{\linewidth}{ l X l}
  \hline type & behaviour & defined in \\ \hline
    \lstinline[style=P4style]!exact! &
    Exact match of the key & \texttt{core.p4} \\
    \lstinline[style=P4style]!ternary! &
    Compare with mask & \texttt{core.p4} \\
    \lstinline[style=P4style]!lpm! &
    Longest prefix match & \texttt{core.p4} \\
    \lstinline[style=P4style]!range! &
    Check if in range & \texttt{v1model.p4} \\ \hline
  \end{tabularx}

  \begin{lstlisting}[style=P4style]
table table_name {
  key = {
    hdr.ethernet.dstAddr : exact;
  }
  actions = {
    forward;
    NoAction;
  }
  size = 5;
  default_action = NoAction;
}\end{lstlisting}

A typical IPv4 lpm L3 switch would look like this:
  \begin{lstlisting}[style=P4style]
action ipv4_forward(macAddr_t dstAddr, egressSpec_t port) {
  hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
  hdr.ethernet.dstAddr = dstAddr;
  standard_metadata.egress_spec = port;
  hdr.ipv4.ttl = hdr.ipv4.ttl - 1;
}
table ipv4_lpm {
  key = {
    hdr.ipv4.dstAddr : lpm;
  }
  actions = {
    ipv4_forward;
    drop;
  }
  size = 2;
  default_action = drop;
}
apply {
  ipv4_lpm.apply();
}\end{lstlisting}

with the table entries:
\begin{lstlisting}[language=bash]
table_set_default   ipv4_lpm drop
table_add           ipv4_lpm ipv4_forward 10.0.2.2/24 => 00:00:0a:00:02:02 1
table_add           ipv4_lpm ipv4_forward 10.0.1.1/24 => 12:00:00:00:00:00 2\end{lstlisting}

  \subsubsection{Deparser}
  Deparse from the bottom to the top. Donâ€™t have to check if a header has to be applied, emit only applies header if it is valid.
  \begin{lstlisting}[style=P4style]
packet.emit(hdr.ethernet);
// don't have to check bcs only valid headers are applied
packet.emit(hdr.ipv4);
packet.emit(hdr.tcp);\end{lstlisting}

  \subsection{Examples}

  \subsubsection{Reflector}
  This is the most basic p4 design. The dataflow is clearly visible:

  \begin{enumerate}
    \item Parse the header fields neccessary for later processing
    \item Apply ingress actions
    \item Apply egress actions
    \item Deparse packets, meaning reapplying the headers
  \end{enumerate}

  Checksum calculation is omited on purpose to shorten the example.

  \begin{lstlisting}[style=P4style]
/* Define headers, structs and metadata */
typedef bit<48> macAddr_t;
header ethernet_t {
  macAddr_t dstAddr;
  macAddr_t srcAddr;
  bit<16>   etherType;
}
struct metadata {
  /* empty */
}
struct headers {
  ethernet_t   ethernet;
}

/* Define a parser */
parser MyParser(packet_in packet,
      out headers hdr,
      inout metadata meta,
      inout standard_metadata_t standard_metadata) {
    state start{
      // extract the ethernet header
      packet.extract(hdr.ethernet);
      transition accept;
    }
}

/* Ingress pipeline */
control MyIngress(inout headers hdr,
      inout metadata meta,
      inout standard_metadata_t standard_metadata) {
  apply {
    // swap mac addresses
    bit<48> tmpAddr;
    tmpAddr = hdr.ethernet.srcAddr;
    hdr.ethernet.srcAddr = hdr.ethernet.dstAddr;
    hdr.ethernet.dstAddr = tmpAddr;

    // set output port to input port
    standard_metadata.egress_spec = standard_metadata.ingress_port;
  }
}

/* Egress processing */
control MyEgress(inout headers hdr,
     inout metadata meta,
     inout standard_metadata_t standard_metadata) {
    apply {  }
}

/* Deparser */
control MyDeparser(packet_out packet, in headers hdr) {
  apply {
    // Deparse = reapply headers
    packet.emit(hdr.ethernet);
  }
}

/* "main" */
V1Switch(
  MyParser(),
  MyIngress(),
  MyEgress(),
  MyDeparser()
) main;\end{lstlisting}


  \subsubsection{Simple table}
  During ingress, multiple tables can be applied to alter the behaviour of the switch. In this example, no parsing is done. The Ingress port is used as a table key. The table entries can call an action and pass arguments to the action.

  \begin{lstlisting}[style=P4style]
control MyIngress(inout headers hdr,
    inout metadata meta,
    inout standard_metadata_t standard_metadata) {

  // A default drop action should always be present
  action drop(){
    mark_to_drop(standard_metadata);
  }
  
  // One action in the table is forward, where the egress port is passed to the action
  action forward(bit<9> egress_port){
    // forward to given port
    standard_metadata.egress_spec = egress_port;
  }

  // Create the table here
  table tbl_repeater {
    key = {
      // key identify on what the table should match on
      standard_metadata.ingress_port : exact;
    }

    // possible actions for this table are
    actions = {
      forward;
      drop;
    }
    // the size to allocate for this table, meaning a max of 2 entries can be written
    size = 2;
    // the default action if no match
    default_action = drop;
  }

  apply {
    // apply the table
    tbl_repeater.apply();
  }
}\end{lstlisting}

  Using simple switch, the commands to fill this table as mentioned are:

  \begin{lstlisting}[language=bash]
table_set_default table_nametbl_repeater drop
table_add tbl_repeater forward 1 => 2
table_add tbl_repeater forward 2 => 1\end{lstlisting}

  \subsubsection{Flooding to other ports}
  A switch has to maintain a MAC table for forwarding information. If the destination MAC is not known to the box, it forwrads it to all ports except the port that the packet came from. The multicasting mechanism is described here.

  The switch behaviour is as followed:
  \begin{enumerate}
    \item Apply MAC table, if hit, forward
    \item If miss, apply multicast table to know which multicast group to forward to
  \end{enumerate}

  \begin{lstlisting}[style=P4style]
  // default drop action
  action drop() {
    mark_to_drop(standard_metadata);
  }

  // forward action if MAC table hit
  action forward(egressSpec_t egress_port){
     // forward to given port
     standard_metadata.egress_spec = egress_port;
  }

  // MAC table
  table t_l2switch {
    key = { hdr.ethernet.dstAddr : exact; }
    actions = {
        forward;
        drop;
    }
    size = 5;
    default_action = drop;
  }

  // set multicast group action
  action set_mgrp(mgrp_t mgrp) {
    standard_metadata.mcast_grp = mgrp;
  }

  // ingress port to multicast group table
  table t_igp_to_mgrp {
    key = { standard_metadata.ingress_port : exact; }
    actions = {
        set_mgrp;
        drop;
    }
    size = 5;
    default_action = drop;
  }

  apply {
    // apply table logic
    if(!t_l2switch.apply().hit) {
        t_igp_to_mgrp.apply();
    }
  }\end{lstlisting}

  Filling tables in simple switch:

  \begin{lstlisting}[language=bash]mc_mgrp_create 1
mc_node_create 0 2 3 4
mc_node_associate 1 0

mc_mgrp_create 2
mc_node_create 1 1 3 4
mc_node_associate 2 1

mc_mgrp_create 3
mc_node_create 2 1 2 4
mc_node_associate 2 1

mc_mgrp_create 4
mc_node_create 3 1 2 3
mc_node_associate 3 2

table_set_default   t_l2switch NoAction
table_add           t_l2switch forward 00:00:0a:00:00:1 => 1
table_add           t_l2switch forward 00:00:0a:00:00:2 => 2
table_add           t_l2switch forward 00:00:0a:00:00:3 => 3
table_add           t_l2switch forward 00:00:0a:00:00:4 => 4

table_set_default   t_igp_to_mgrp NoAction
table_add           t_igp_to_mgrp set_mgrp 1 => 1
table_add           t_igp_to_mgrp set_mgrp 2 => 2
table_add           t_igp_to_mgrp set_mgrp 3 => 3
table_add           t_igp_to_mgrp set_mgrp 4 => 4\end{lstlisting}


  \subsubsection{Multicast group ID}
  For a L2-switch to work, it has to multicast packets. Simple switch has a multicast features that
  allows setting a metadata field so that packets are sent to multiple ports.

  First, on the switch, create a multicast group, node and assign these.
  \begin{lstlisting}[language=bash]
mc_mgrp_create <mcast_grp_id>
mc_node_create <replication_id> <port_number> [port_number]
mc_node_associate <mcast_grp_id> <node_handle_id>\end{lstlisting}
  
  \texttt{mc\_node\_create} returns the \texttt{node\_handle\_id}. For every \texttt{replication\_id} the \texttt{mc\_node\_create} is incremented.

  Example: Mulcicast \texttt{mcast\_grp\_id=1} with \texttt{replication\_id=0} on ports \texttt{1,2,3,4} 
  \begin{lstlisting}[language=bash]
mc_mgrp_create 1
mc_node_create 0 1 2 3 4
mc_node_associate 1 0\end{lstlisting}

  To send a packet to this group, in P4 set the \texttt{standard\_metadata.mcast\_grp} to \texttt{mcast\_grp\_id} during the ingress pipeline.

  \subsubsection{Cloning Packets}
  Is a feature of simple switch.

  Configure the switch with a mirroring session \texttt{session} mapped to an \texttt{output\_port}.
  \begin{lstlisting}[style=P4style]
mirroring_add <session> <output_port>\end{lstlisting}

  During ingress pipeline, a packet can be cloned using \texttt{clone}. The packet will be cloned to the egress pipeline and port configured by \texttt{mirroring\_add}. When using \texttt{clone3} you can add as a third parameter a metadata \texttt{struct}.
  \begin{lstlisting}[style=P4style]
clone(CloneType.I2E, <session>)
// Generally
clone(in CloneType type, in bit<32> session)
clone3<T>(in CloneType type, in bit<32> session, in T data)\end{lstlisting}

  To identify a cloned packet in the egress pipeline, check the \texttt{standard\_metadata.instance\_type==1} field.

  When a packet is cloned all its metadata fields
  are reset to the default value (usually 0).


  \subsubsection{Digest packets}
  A feature of simple switch to send packets to the controller without having to clone it.

  \begin{lstlisting}[style=P4style]
// Define a struct that is sent to the controller
struct learn_t {
  macAddr_t srcAddr;
  inPort_t  inPort;
}
// Add the struct to the metadata
struct metadata {
  /* empty */
  //TODO 3: delcare one learn_t variable
  learn_t learn;
}
// fill in the meatdata fields
meta.learn.srcAddr = hdr.ethernet.srcAddr;
meta.learn.inPort = (inPort_t)standard_metadata.ingress_port;
// send to the controller
// nothing else has to be done
digest(1, meta.learn); // first argument is always 1\end{lstlisting}

  
\end{multicols*}

\setcounter{secnumdepth}{2}
\end{document}
